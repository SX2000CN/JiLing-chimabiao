# 尺码表预览自适应优化说明

## 🎯 问题描述

原始的尺码表预览组件使用固定的 800x800 像素Canvas尺寸，导致在程序窗口缩放时（特别是最小缩放状态下）预览表格显示不全，用户体验不佳。

## 🔧 解决方案

### 核心改进

1. **动态Canvas尺寸计算**
   - 根据容器实际尺寸动态计算Canvas最佳尺寸
   - 保持正方形比例，选择宽高中的较小值
   - 设置合理的最小值（300px）和最大值（1000px）限制

2. **响应式尺寸监听**
   - 使用 `ResizeObserver` API 监听容器尺寸变化
   - 监听窗口 `resize` 事件作为后备方案
   - 自动重新计算并更新Canvas尺寸

3. **优化的容器布局**
   - 为容器添加 `min-height: 400px` 确保最小显示区域
   - Canvas添加 `max-width: 100%` 和 `max-height: 100%` 约束
   - 保持原有的缩放控制功能

## 📝 具体修改

### 文件：`src/components/PreviewPanel.jsx`

#### 1. 状态管理增强
```jsx
const [canvasSize, setCanvasSize] = useState({ width: 800, height: 800 });
const containerRef = useRef(null);
```

#### 2. 尺寸计算逻辑
```jsx
const calculateCanvasSize = useCallback(() => {
  if (!containerRef.current) return { width: 800, height: 800 };
  
  const container = containerRef.current;
  const containerRect = container.getBoundingClientRect();
  
  // 减去padding和安全间距
  const availableWidth = containerRect.width - 48;
  const availableHeight = containerRect.height - 48;
  
  // 保持正方形，选择较小尺寸
  const maxSize = Math.min(availableWidth, availableHeight);
  
  // 设置边界限制
  const minSize = 300;
  const maxSize_limit = 1000;
  
  const finalSize = Math.max(minSize, Math.min(maxSize, maxSize_limit));
  
  return { width: finalSize, height: finalSize };
}, []);
```

#### 3. 响应式监听
```jsx
useEffect(() => {
  const updateCanvasSize = () => {
    const newSize = calculateCanvasSize();
    setCanvasSize(newSize);
  };

  // 监听窗口变化
  window.addEventListener('resize', handleResize);
  
  // 使用ResizeObserver监听容器变化
  let resizeObserver;
  if (window.ResizeObserver && containerRef.current) {
    resizeObserver = new ResizeObserver(handleResize);
    resizeObserver.observe(containerRef.current);
  }

  return () => {
    window.removeEventListener('resize', handleResize);
    if (resizeObserver && containerRef.current) {
      resizeObserver.unobserve(containerRef.current);
    }
  };
}, [calculateCanvasSize]);
```

#### 4. Canvas渲染优化
```jsx
// 使用动态尺寸渲染
canvas.width = canvasSize.width;
canvas.height = canvasSize.height;
ctx.drawImage(img, 0, 0, canvasSize.width, canvasSize.height);
```

#### 5. UI增强
- 在控制栏添加实时尺寸显示：`{canvasSize.width}×{canvasSize.height}`
- 调试日志输出容器和Canvas尺寸信息

## ✨ 用户体验改进

### 前：
- 固定800x800像素，在小窗口中显示不全
- 需要手动滚动查看完整表格
- 缩放功能与窗口大小不协调

### 后：
- 自动适应窗口大小，始终显示完整预览
- 在最小窗口下也能清晰查看整个尺码表
- 缩放功能与自适应尺寸完美配合
- 实时显示当前Canvas尺寸信息

## 🔧 技术特性

- **响应式设计**：自动适应各种窗口尺寸
- **性能优化**：使用useCallback避免不必要的重新计算
- **边界保护**：设置最小/最大尺寸防止异常情况
- **优雅降级**：ResizeObserver不支持时使用resize事件
- **调试友好**：包含详细的尺寸计算日志

## 🚀 兼容性

- 支持现代浏览器的ResizeObserver API
- 在不支持ResizeObserver的环境中自动降级到resize事件
- 保持原有的所有功能和API不变
- 向后兼容现有的导出和缩放功能

## 📊 测试验证

1. **窗口最小化测试**：将应用窗口缩放到最小尺寸，验证预览表格完整显示
2. **响应式测试**：动态调整窗口大小，验证Canvas实时自适应
3. **功能测试**：确认导出、缩放等原有功能正常工作
4. **性能测试**：验证尺寸计算不会造成性能问题

## 🎯 效果总结

通过这次优化，尺码表预览功能现在能够：
- ✅ 在任何窗口尺寸下完整显示预览内容
- ✅ 实时响应窗口大小变化
- ✅ 保持最佳的显示比例和清晰度
- ✅ 提供更好的用户体验和视觉效果

这一改进特别解决了用户在使用小窗口或最小缩放时无法查看完整尺码表的问题，显著提升了软件的实用性和用户满意度。
