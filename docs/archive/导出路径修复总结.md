# 🔧 导出路径修复总结

## 🔍 问题诊断
用户反馈的问题：
1. ❌ 设置保存路径的地方被当作文件名了
2. ❌ 快捷键仍然弹出保存对话框选择路径
3. ❌ 保存的文件名变成了设置里的路径

## 🎯 根本原因
**参数传递错误**: 在PreviewPanel.jsx中调用downloadImage时，参数顺序不正确：

**错误的调用**:
```javascript
// 参数顺序错误，exportPath被当作filename
await downloadImage(imageDataUrl, undefined, appState.exportPath);
```

**正确的调用**:
```javascript
// 修复后的参数顺序
await downloadImage(imageDataUrl, appState.exportPath, '尺码表');
```

## 🛠️ 解决方案

### 1. 修复参数传递 (PreviewPanel.jsx)
```javascript
// 如果设置了导出路径，直接保存；否则弹出下载对话框
if (appState.exportPath) {
  console.log('使用设置的导出路径:', appState.exportPath);
  await downloadImage(imageDataUrl, appState.exportPath, '尺码表');
} else {
  console.log('未设置导出路径，使用传统下载方式');
  const filename = `尺码表_${new Date().toISOString().slice(0, 10)}`;
  downloadImage(imageDataUrl, null, filename);
}
```

### 2. 添加图片保存API (ipcHandler.cjs)
```javascript
// 保存图片到指定路径
ipcMain.handle('file:saveImage', async (event, filePath, base64Data) => {
  try {
    const dir = path.dirname(filePath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }

    // 将base64数据转换为Buffer
    const buffer = Buffer.from(base64Data, 'base64');
    fs.writeFileSync(filePath, buffer);
    
    return {
      success: true,
      path: filePath,
      message: '图片保存成功'
    };
  } catch (error) {
    return {
      success: false,
      message: '保存图片失败: ' + error.message,
      error: error
    };
  }
});
```

### 3. 暴露新API (preload.cjs)
```javascript
saveImageToPath: (filePath, base64Data) => ipcRenderer.invoke('file:saveImage', filePath, base64Data),
fileExists: (filePath) => ipcRenderer.invoke('file:exists', filePath),
```

### 4. 修复文件名生成逻辑 (tableExporter.js)
```javascript
const generateUniqueFileName = async (basePath, baseName, extension) => {
  if (window.electronAPI && window.electronAPI.fileExists) {
    let counter = 1;
    let fileName = `${baseName}${counter}.${extension}`;
    let fullPath = `${basePath}\\${fileName}`;

    // 检查文件是否存在，递增计数器避免覆盖
    const checkResult = await window.electronAPI.fileExists(fullPath);
    while (checkResult.success && checkResult.exists) {
      counter++;
      fileName = `${baseName}${counter}.${extension}`;
      fullPath = `${basePath}\\${fileName}`;
      // 继续检查新文件名...
    }

    return fullPath;
  }
  return `${baseName}.${extension}`;
};
```

## 🎯 修复后的功能

### ✅ 正确的导出流程
1. **设置导出路径**: 设置 → 通用设置 → 导出路径 → 浏览文件夹
2. **智能文件命名**: 
   - 第一次保存: `尺码表1.jpg`
   - 第二次保存: `尺码表2.jpg` 
   - 以此类推，避免文件覆盖
3. **快捷键导出**: 按Ctrl+S直接保存到设置的路径，无需弹窗
4. **未设置路径**: 如果没有设置路径，则弹出传统的保存对话框

### 🔍 调试信息
添加了控制台日志方便调试：
- "使用设置的导出路径: [路径]"
- "未设置导出路径，使用传统下载方式"
- "Export shortcut event received: {format: 'jpeg'}"

## 📋 测试步骤

### 1. 测试路径设置
- 打开设置 → 通用设置
- 点击"导出路径"旁的"浏览"按钮
- 选择一个文件夹
- 确认路径正确显示

### 2. 测试快捷键导出
- 生成尺码表数据
- 按Ctrl+S
- 验证文件直接保存到设置的文件夹
- 检查文件名为"尺码表1.jpg"

### 3. 测试文件名递增
- 再次按Ctrl+S
- 验证新文件名为"尺码表2.jpg"
- 原文件不被覆盖

### 4. 测试未设置路径情况
- 清空导出路径设置
- 按Ctrl+S或点击导出按钮
- 验证弹出保存对话框

## 🎉 预期结果
- ✅ 导出路径设置正常工作
- ✅ 快捷键Ctrl+S直接保存，无弹窗
- ✅ 智能文件名递增，避免覆盖
- ✅ 5倍超分辨率高清导出
- ✅ 完整的错误处理和日志记录
