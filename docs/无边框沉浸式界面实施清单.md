# 无边框沉浸式界面实施清单

## 🎯 目标分析

将当前带标题栏的 Windows 窗口改造为无边框沉浸式界面，同时保持所有窗口控制功能和原有应用特性。

## 📋 详细实施清单

### 1. Electron 主进程配置修改

#### 文件：`main.cjs`

#### 位置：`createWindow()` 方法中的 `BrowserWindow` 配置

**当前配置：**

```javascript
this.mainWindow = new BrowserWindow({
  width: 1200,
  height: 800,
  minWidth: 800,
  minHeight: 600,
  // frame 属性默认为 true
})
```

**修改为：**

```javascript
this.mainWindow = new BrowserWindow({
  width: 1200,
  height: 800,
  minWidth: 800,
  minHeight: 600,
  frame: false,              // 移除系统标题栏和边框
  titleBarStyle: 'hidden',   // macOS 兼容
  titleBarOverlay: false,    // 禁用标题栏覆盖
  transparent: false,        // 保持非透明（避免性能问题）
  // 其他配置保持不变
});

// 重要：设置无边框标志供后续检测使用
this.mainWindow.isFrameless = true;
```

**附加配置项：**

- `resizable: true` - 确保窗口可调整大小
- `maximizable: true` - 确保窗口可最大化
- `minimizable: true` - 确保窗口可最小化

### 2. 窗口控制 IPC 通信扩展

#### 文件：`preload.cjs`

#### 位置：`contextBridge.exposeInMainWorld` 中的 `electronAPI`

**需要添加的 API：**

```javascript
// 在 contextBridge.exposeInMainWorld('electronAPI', { ... }) 中添加
window: {
  close: () => ipcRenderer.invoke('window-close'),
  minimize: () => ipcRenderer.invoke('window-minimize'),
  maximize: () => ipcRenderer.invoke('window-maximize'),
  unmaximize: () => ipcRenderer.invoke('window-unmaximize'),
  toggleMaximize: () => ipcRenderer.invoke('window-toggle-maximize'),
  isMaximized: () => ipcRenderer.invoke('window-is-maximized'),
  isMinimized: () => ipcRenderer.invoke('window-is-minimized'),
  setAlwaysOnTop: (flag) => ipcRenderer.invoke('window-set-always-on-top', flag)
}
```

### 3. 主进程 IPC 事件处理

#### 文件：`src/services/backend/ipcHandler.cjs`

#### 位置：在构造函数中注册新的 IPC 处理器

**需要添加的事件处理器：**

```javascript
// 窗口控制事件处理器
setupWindowHandlers() {
  ipcMain.handle('window-close', () => {
    const mainWindow = this.getMainWindow();
    if (mainWindow) mainWindow.close();
  });

  ipcMain.handle('window-minimize', () => {
    const mainWindow = this.getMainWindow();
    if (mainWindow) mainWindow.minimize();
  });

  ipcMain.handle('window-maximize', () => {
    const mainWindow = this.getMainWindow();
    if (mainWindow) mainWindow.maximize();
  });

  ipcMain.handle('window-unmaximize', () => {
    const mainWindow = this.getMainWindow();
    if (mainWindow) mainWindow.unmaximize();
  });

  ipcMain.handle('window-toggle-maximize', () => {
    const mainWindow = this.getMainWindow();
    if (mainWindow) {
      if (mainWindow.isMaximized()) {
        mainWindow.unmaximize();
      } else {
        mainWindow.maximize();
      }
    }
  });

  ipcMain.handle('window-is-maximized', () => {
    const mainWindow = this.getMainWindow();
    return mainWindow ? mainWindow.isMaximized() : false;
  });

  ipcMain.handle('window-is-minimized', () => {
    const mainWindow = this.getMainWindow();
    return mainWindow ? mainWindow.isMinimized() : false;
  });

  ipcMain.handle('window-set-always-on-top', (event, flag) => {
    const mainWindow = this.getMainWindow();
    if (mainWindow) mainWindow.setAlwaysOnTop(flag);
  });
}
```

**获取主窗口的方法（修正版）：**

```javascript
getMainWindow() {
  // 方法 1: 使用 BrowserWindow 静态方法（推荐）
  return BrowserWindow.getFocusedWindow() || BrowserWindow.getAllWindows()[0];
  
  // 方法 2: 如果需要特定窗口引用，可以在构造函数中接收
  // constructor(mainWindow) {
  //   this.mainWindow = mainWindow;
  //   // ...其他初始化代码
  // }
  // 
  // getMainWindow() {
  //   return this.mainWindow;
  // }
}
```

**在构造函数中调用：**

```javascript
constructor(mainWindow = null) {
  this.database = new LocalDatabase();
  this.excelExporter = new ExcelExporter();
  this.dataMigration = new DataMigration(this.database);
  this.mainWindow = mainWindow; // 可选：接收主窗口引用
  this.isInitialized = false;
  
  this.setupIPCHandlers();
}

setupIPCHandlers() {
  // 现有的处理器设置...
  // 例如：数据库操作、Excel 导出等 IPC 处理器
  
  // 新增窗口控制处理器
  this.setupWindowHandlers();
}

// 注意：setupWindowHandlers 方法需要在同一个 IPCHandler 类中定义
// 它应该包含上面第3步中定义的所有窗口控制事件处理器
```

**重要：在 main.cjs 中需要修改 IPCHandler 的实例化方式：**

```javascript
// 在 Application 类的构造函数中
this.createWindow(); // 先创建窗口
this.ipcHandler = new IPCHandler(this.mainWindow); // 传递窗口引用

// 同时确保正确导入 BrowserWindow
const { BrowserWindow, ipcMain } = require('electron');
```

**注意：确保所有必要的依赖都已正确导入：**

- 在 ipcHandler.cjs 中需要导入 `{ ipcMain, BrowserWindow }`
- 在 preload.cjs 中需要导入 `{ contextBridge, ipcRenderer }`

### 4. 自定义窗口控制组件

#### 文件：`src/components/WindowControls.jsx` (新建)

#### 功能：实现 macOS 风格的窗口控制按钮

#### 重要说明：有两种实现方式

1. **基础版本**：适用于单一平台或不需要平台兼容性的情况
2. **平台兼容版本**：适用于需要在不同操作系统上调整布局的情况（参见第8步）

**基础版本组件结构：**

```jsx
import React, { useState, useEffect } from 'react';
import styled from 'styled-components';

// 窗口控制容器
const WindowControls = styled.div`
  display: flex;
  align-items: center;
  gap: 8px;
  -webkit-app-region: no-drag;
  padding: 8px 12px;
`;

// 控制按钮
const ControlButton = styled.button`
  width: 12px;
  height: 12px;
  border-radius: 50%;
  border: none;
  cursor: pointer;
  transition: all 0.2s ease;
  position: relative;
  
  &:hover {
    transform: scale(1.1);
  }
  
  &.close {
    background: #ff5f57;
    &:hover::after {
      content: '×';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #4a0000;
      font-size: 8px;
      font-weight: bold;
    }
  }
  
  &.minimize {
    background: #ffbd2e;
    &:hover::after {
      content: '−';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #7a4a00;
      font-size: 8px;
      font-weight: bold;
    }
  }
  
  &.maximize {
    background: #28ca42;
    &:hover::after {
      content: '□';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #0a4a1a;
      font-size: 6px;
      font-weight: bold;
    }
  }
`;
```

**组件逻辑：**

```jsx
const WindowControlsComponent = () => {
  const [isMaximized, setIsMaximized] = useState(false);

  useEffect(() => {
    const checkMaximized = async () => {
      if (window.electronAPI?.window?.isMaximized) {
        const maximized = await window.electronAPI.window.isMaximized();
        setIsMaximized(maximized);
      }
    };
    
    checkMaximized();
    
    // 监听窗口状态变化（降低轮询频率以提高性能）
    const interval = setInterval(checkMaximized, 1000); // 改为1秒检查一次
    return () => clearInterval(interval);
  }, []);

  const handleClose = () => {
    window.electronAPI?.window?.close();
  };

  const handleMinimize = () => {
    window.electronAPI?.window?.minimize();
  };

  const handleMaximize = () => {
    window.electronAPI?.window?.toggleMaximize();
  };

  return (
    <WindowControls>
      <ControlButton className="close" onClick={handleClose} title="关闭" />
      <ControlButton className="minimize" onClick={handleMinimize} title="最小化" />
      <ControlButton 
        className="maximize" 
        onClick={handleMaximize} 
        title={isMaximized ? "还原" : "最大化"} 
      />
    </WindowControls>
  );
};

export default WindowControlsComponent;
```

#### 注意：如果需要平台兼容性，请参考第8步将 WindowControls 替换为 PlatformAwareWindowControls

### 5. 工具栏组件修改

#### 文件：`src/components/Toolbar.jsx`

#### 修改内容：集成自定义窗口控制组件和拖拽功能

**CSS 修改：**

```javascript
const ToolbarContainer = styled.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  height: 52px;
  background: ${props => props.theme.colors.background.primary};
  border-bottom: 1px solid ${props => props.theme.colors.border.light};
  padding: 0 16px;
  gap: 16px;
  -webkit-app-region: drag;  /* 允许拖拽整个工具栏 */
`;

const ToolbarSection = styled.div`
  display: flex;
  align-items: center;
  gap: 12px;
  -webkit-app-region: no-drag;  /* 按钮和控件区域禁止拖拽 */
`;
```

**组件结构修改：**

```jsx
import React from 'react';
import styled from 'styled-components';
import WindowControlsComponent from './WindowControls';

const Toolbar = ({ appState, setAppState, onGenerate, ...props }) => {
  return (
    <ToolbarContainer {...props}>
      <ToolbarSection>
        <WindowControlsComponent />  {/* 使用正确的组件名 */}
        
        {/* 现有的模式选择器等组件 */}
        <ModeSelector>
          {/* 现有内容 */}
        </ModeSelector>
        
        {/* 现有的状态指示器 */}
        <StatusIndicator>
          {/* 现有内容 */}
        </StatusIndicator>
      </ToolbarSection>

      <ToolbarSection>
        {/* 现有的右侧内容 */}
      </ToolbarSection>
    </ToolbarContainer>
  );
};

export default Toolbar;
```

### 6. 窗口状态管理

#### 实现窗口状态的实时监听和更新

#### 方法 1：轮询检查

```javascript
// 在 WindowControls 组件中
useEffect(() => {
  const checkWindowState = async () => {
    if (window.electronAPI?.window) {
      const maximized = await window.electronAPI.window.isMaximized();
      setIsMaximized(maximized);
    }
  };
  
  // 建议使用1秒间隔以优化性能
  const interval = setInterval(checkWindowState, 1000);
  return () => clearInterval(interval);
}, []);
```

#### 方法 2：事件监听（推荐）

```javascript
// 在主进程中添加窗口事件监听
// 重要：这些事件监听器应该在 main.cjs 的 createWindow() 方法中，
// 在创建 BrowserWindow 之后立即添加

// 在 main.cjs 的 createWindow() 方法中添加：
this.mainWindow = new BrowserWindow({
  // ... 窗口配置
});

// 立即添加窗口状态事件监听
this.mainWindow.on('maximize', () => {
  this.mainWindow.webContents.send('window-state-changed', { maximized: true });
});

this.mainWindow.on('unmaximize', () => {
  this.mainWindow.webContents.send('window-state-changed', { maximized: false });
});

// 可选：添加其他窗口状态事件
this.mainWindow.on('minimize', () => {
  this.mainWindow.webContents.send('window-state-changed', { minimized: true });
});

this.mainWindow.on('restore', () => {
  this.mainWindow.webContents.send('window-state-changed', { minimized: false });
});

// 在 preload.cjs 中添加事件监听
// 方法1：直接在 contextBridge 中暴露事件监听
contextBridge.exposeInMainWorld('electronAPI', {
  // ... 其他 API
  onWindowStateChanged: (callback) => {
    ipcRenderer.on('window-state-changed', (event, state) => callback(state));
  },
  removeWindowStateListener: () => {
    ipcRenderer.removeAllListeners('window-state-changed');
  }
});

// 方法2：或者在 preload 中直接设置全局事件
ipcRenderer.on('window-state-changed', (event, state) => {
  // 确保 DOM 已加载后再分发事件
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      window.dispatchEvent(new CustomEvent('window-state-changed', { detail: state }));
    });
  } else {
    window.dispatchEvent(new CustomEvent('window-state-changed', { detail: state }));
  }
});

// 在 WindowControls 组件中监听（更新版）
useEffect(() => {
  const handleWindowStateChange = (event) => {
    setIsMaximized(event.detail.maximized);
  };
  
  // 方法1：使用全局事件（如果使用 preload 方法2）
  window.addEventListener('window-state-changed', handleWindowStateChange);
  
  // 方法2：使用 contextBridge API（如果使用 preload 方法1）
  // if (window.electronAPI?.onWindowStateChanged) {
  //   window.electronAPI.onWindowStateChanged((state) => {
  //     setIsMaximized(state.maximized);
  //   });
  // }
  
  return () => {
    window.removeEventListener('window-state-changed', handleWindowStateChange);
    // 如果使用方法2，也要清理：
    // window.electronAPI?.removeWindowStateListener?.();
  };
}, []);
```

### 7. 双击标题栏功能

#### 在工具栏组件中添加双击事件处理

```javascript
const ToolbarContainer = styled.div`
  /* 现有样式 */
  
  &:not([data-no-drag]) {
    -webkit-app-region: drag;
  }
`;

// 在 Toolbar 组件中添加
const handleDoubleClick = (event) => {
  // 确保双击事件不是在按钮或其他交互元素上触发
  if (event.target.tagName === 'BUTTON' || event.target.closest('button')) {
    return;
  }
  
  if (window.electronAPI?.window?.toggleMaximize) {
    window.electronAPI.window.toggleMaximize();
  }
};

return (
  <ToolbarContainer onDoubleClick={handleDoubleClick} {...props}>
    {/* 组件内容 */}
  </ToolbarContainer>
);
```

### 8. 平台兼容性处理

#### 根据操作系统调整窗口控制按钮位置

```javascript
// 在 WindowControls 组件中检测操作系统
import React, { useState, useEffect } from 'react';
import styled from 'styled-components';

// 预定义样式组件（在组件外部）
const WindowControlsContainer = styled.div`
  display: flex;
  align-items: center;
  gap: 8px;
  -webkit-app-region: no-drag;
`;

// 根据平台调整的动态样式组件
const PlatformAwareWindowControls = styled(WindowControlsContainer)`
  ${props => props.platform === 'darwin' ? `
    /* macOS: 左上角 */
    order: -1;
  ` : `
    /* Windows/Linux: 右上角 */
    order: 1;
    margin-left: auto;
  `}
`;

// 控制按钮样式（与第4步相同，确保平台兼容版本可用）
const ControlButton = styled.button`
  width: 12px;
  height: 12px;
  border-radius: 50%;
  border: none;
  cursor: pointer;
  transition: all 0.2s ease;
  position: relative;
  
  &:hover {
    transform: scale(1.1);
  }
  
  &.close {
    background: #ff5f57;
    &:hover::after {
      content: '×';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #4a0000;
      font-size: 8px;
      font-weight: bold;
    }
  }
  
  &.minimize {
    background: #ffbd2e;
    &:hover::after {
      content: '−';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #7a4a00;
      font-size: 8px;
      font-weight: bold;
    }
  }
  
  &.maximize {
    background: #28ca42;
    &:hover::after {
      content: '□';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #0a4a1a;
      font-size: 6px;
      font-weight: bold;
    }
  }
`;

const WindowControlsComponent = () => {
  const [platform, setPlatform] = useState('unknown');
  const [isMaximized, setIsMaximized] = useState(false);

  useEffect(() => {
    // 通过 Electron API 获取平台信息
    if (window.electronAPI?.platform?.getPlatform) {
      window.electronAPI.platform.getPlatform().then(setPlatform);
    }
  }, []);

  useEffect(() => {
    // 检查窗口状态
    const checkMaximized = async () => {
      if (window.electronAPI?.window?.isMaximized) {
        const maximized = await window.electronAPI.window.isMaximized();
        setIsMaximized(maximized);
      }
    };
    
    checkMaximized();
    const interval = setInterval(checkMaximized, 1000);
    return () => clearInterval(interval);
  }, []);

  const handleClose = () => {
    window.electronAPI?.window?.close();
  };

  const handleMinimize = () => {
    window.electronAPI?.window?.minimize();
  };

  const handleMaximize = () => {
    window.electronAPI?.window?.toggleMaximize();
  };

  // 组件渲染逻辑...
  return (
    <PlatformAwareWindowControls platform={platform}>
      <ControlButton className="close" onClick={handleClose} title="关闭" />
      <ControlButton className="minimize" onClick={handleMinimize} title="最小化" />
      <ControlButton 
        className="maximize" 
        onClick={handleMaximize} 
        title={isMaximized ? "还原" : "最大化"} 
      />
    </PlatformAwareWindowControls>
  );
};
```

**在 preload.cjs 中添加平台检测 API：**

```javascript
// 在 contextBridge.exposeInMainWorld 的 electronAPI 中添加
{
  window: {
    // ... 现有的窗口控制 API（参见第2步）
  },
  platform: {
    getPlatform: () => ipcRenderer.invoke('get-platform')
  }
}
```

**在 ipcHandler.cjs 中添加平台检测处理器：**

```javascript
ipcMain.handle('get-platform', () => {
  return process.platform; // 返回 'darwin', 'win32', 'linux' 等
});
```

### 9. 边缘拖拽调整大小保持

#### 确保无边框窗口仍可调整大小

**主进程配置确认：**

```javascript
// 在 BrowserWindow 配置中确保
{
  frame: false,
  resizable: true,  // 确保可调整大小
  // Electron 会自动处理边缘拖拽
}
```

**重要说明：**

- 无边框窗口默认情况下，Electron 会自动在窗口边缘提供调整大小的功能
- 用户可以通过拖拽窗口边缘来调整大小，无需额外代码
- 如果发现边缘拖拽不工作，检查是否有 CSS 样式干扰了边缘区域
- 确保窗口内容不要使用 `pointer-events: none` 等可能影响边缘检测的样式

### 10. 错误处理和降级方案

#### 添加错误处理和回退机制

```javascript
// 在窗口控制函数中添加错误处理
const handleClose = () => {
  try {
    if (window.electronAPI?.window?.close) {
      window.electronAPI.window.close();
    } else {
      console.warn('窗口控制 API 不可用');
      // 降级方案：使用传统方法
      window.close();
    }
  } catch (error) {
    console.error('关闭窗口失败:', error);
  }
};

// 检测是否为无边框模式的正确方法
const useFramelessDetection = () => {
  const [isFrameless, setIsFrameless] = useState(false);
  
  useEffect(() => {
    const checkFrameless = async () => {
      try {
        if (window.electronAPI?.window?.isFrameless) {
          const frameless = await window.electronAPI.window.isFrameless();
          setIsFrameless(frameless);
        }
      } catch (error) {
        console.error('检测无边框模式失败:', error);
        // 默认假设非无边框模式
        setIsFrameless(false);
      }
    };
    
    checkFrameless();
  }, []);
  
  return isFrameless;
};

// 在组件中使用
const SomeComponent = () => {
  const isFrameless = useFramelessDetection();
  
  return (
    <div>
      {isFrameless && <WindowControlsComponent />}
      {/* 其他内容 */}
    </div>
  );
};
```

**在 preload.cjs 中添加无边框检测 API：**

```javascript
// 在已有的 window 对象中添加无边框检测方法
window: {
  // ... 现有的窗口控制 API（参见第2步）
  isFrameless: () => ipcRenderer.invoke('window-is-frameless')  // 新增的 API
}
```

**在 ipcHandler.cjs 中添加检测处理器：**

```javascript
ipcMain.handle('window-is-frameless', () => {
  const mainWindow = this.getMainWindow();
  if (mainWindow) {
    // 正确的检查方法：检查窗口是否设置了自定义标志
    return mainWindow.isFrameless === true;
  }
  return false;
});

// 建议：在创建窗口时设置标志
// 在 main.cjs 的 createWindow 方法中：
// this.mainWindow.isFrameless = true; // 如果设置了 frame: false
```

### 11. 测试验证清单

#### 功能测试项目

- [ ] 窗口拖拽移动正常
- [ ] 关闭按钮功能正常
- [ ] 最小化按钮功能正常
- [ ] 最大化/还原按钮功能正常
- [ ] 双击标题栏最大化/还原功能正常
- [ ] 边缘拖拽调整窗口大小正常
- [ ] 窗口状态指示器更新正常
- [ ] 按钮 hover 效果正常
- [ ] 不同操作系统下布局正确
- [ ] 无边框检测 API 工作正常
- [ ] 平台检测 API 返回正确值
- [ ] 窗口控制按钮在不同平台下位置正确

#### 性能测试项目

- [ ] 拖拽操作流畅
- [ ] 窗口状态检查不影响性能
- [ ] 无内存泄漏
- [ ] CPU 占用正常

### 12. 回滚方案

#### 快速回滚到有边框模式

**备份文件：**

```bash
# 备份现有文件
cp main.cjs main-frameless.cjs
cp src/components/Toolbar.jsx src/components/Toolbar-frameless.jsx
```

**回滚步骤：**

1. 在 `main.cjs` 中移除 `frame: false`
2. 在 `Toolbar.jsx` 中移除 `WindowControlsComponent` 组件
3. 移除 `-webkit-app-region` 相关样式
4. 移除窗口控制相关的 IPC 处理器

## 🎯 实施优先级

### 高优先级（核心功能）

1. Electron 主进程配置修改
2. 自定义窗口控制组件
3. 工具栏拖拽区域设置
4. 基础窗口控制 IPC 通信

### 中优先级（用户体验）

1. 窗口状态实时监听
2. 双击标题栏功能
3. 按钮 hover 效果
4. 错误处理机制

### 低优先级（完善功能）

1. 平台兼容性优化
2. 性能监控
3. 高级窗口控制功能
4. 视觉效果优化

## ⚠️ 注意事项

1. **保持现有功能完整性**：确保无边框改造不影响应用的核心功能
2. **渐进式实施**：按步骤实施，每步完成后测试功能
3. **跨平台兼容**：考虑 Windows、macOS、Linux 的差异
4. **性能影响**：避免频繁的窗口状态检查影响性能，推荐使用事件监听而非轮询
5. **用户体验**：确保拖拽和窗口控制的响应性良好
6. **架构设计**：确保 IPC 处理器能正确访问主窗口实例，建议通过构造函数传递引用
7. **错误处理**：为所有窗口控制操作添加适当的错误处理和降级方案

## 🔧 性能优化建议

1. **优先使用事件监听**：相比轮询检查，事件监听更高效且实时性更好
2. **合理设置轮询间隔**：如必须使用轮询，建议间隔不少于1秒
3. **避免重复创建组件**：styled-components 应定义在组件外部
4. **内存泄漏防范**：确保所有事件监听器和定时器在组件卸载时正确清理

这个实施清单提供了完整的无边框沉浸式界面实现方案，涵盖了从基础配置到高级功能的所有细节。
